//! Trading signal types.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Type of trading signal.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SignalType {
    /// Buy signal (open long or close short)
    Buy,
    /// Sell signal (open short or close long)
    Sell,
    /// Hold - no action
    Hold,
    /// Specifically close a long position
    CloseLong,
    /// Specifically close a short position
    CloseShort,
}

impl SignalType {
    /// Check if this is an entry signal.
    pub fn is_entry(&self) -> bool {
        matches!(self, SignalType::Buy | SignalType::Sell)
    }

    /// Check if this is an exit signal.
    pub fn is_exit(&self) -> bool {
        matches!(self, SignalType::CloseLong | SignalType::CloseShort)
    }

    /// Check if this signal requires action.
    pub fn requires_action(&self) -> bool {
        !matches!(self, SignalType::Hold)
    }
}

impl std::fmt::Display for SignalType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SignalType::Buy => write!(f, "BUY"),
            SignalType::Sell => write!(f, "SELL"),
            SignalType::Hold => write!(f, "HOLD"),
            SignalType::CloseLong => write!(f, "CLOSE_LONG"),
            SignalType::CloseShort => write!(f, "CLOSE_SHORT"),
        }
    }
}

/// Signal strength/conviction level.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum SignalStrength {
    /// Weak signal - low conviction
    Weak,
    /// Moderate signal - medium conviction
    Moderate,
    /// Strong signal - high conviction
    Strong,
}

impl SignalStrength {
    /// Get a numeric multiplier for position sizing.
    pub fn multiplier(&self) -> f64 {
        match self {
            SignalStrength::Weak => 0.5,
            SignalStrength::Moderate => 1.0,
            SignalStrength::Strong => 1.5,
        }
    }
}

impl Default for SignalStrength {
    fn default() -> Self {
        SignalStrength::Moderate
    }
}

impl std::fmt::Display for SignalStrength {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            SignalStrength::Weak => write!(f, "WEAK"),
            SignalStrength::Moderate => write!(f, "MODERATE"),
            SignalStrength::Strong => write!(f, "STRONG"),
        }
    }
}

/// Additional metadata about a signal.
#[derive(Debug, Clone, Default, Serialize, Deserialize)]
pub struct SignalMetadata {
    /// Name of the strategy that generated the signal
    pub strategy_name: String,
    /// Indicator values at the time of the signal
    pub indicators: HashMap<String, f64>,
    /// Human-readable reason for the signal
    pub reason: String,
    /// Suggested stop-loss price
    pub stop_loss: Option<f64>,
    /// Suggested take-profit price
    pub take_profit: Option<f64>,
    /// Custom key-value pairs
    pub custom: HashMap<String, String>,
}

impl SignalMetadata {
    /// Create new metadata with a strategy name.
    pub fn new(strategy_name: impl Into<String>) -> Self {
        Self {
            strategy_name: strategy_name.into(),
            ..Default::default()
        }
    }

    /// Add an indicator value.
    pub fn with_indicator(mut self, name: impl Into<String>, value: f64) -> Self {
        self.indicators.insert(name.into(), value);
        self
    }

    /// Set the reason for the signal.
    pub fn with_reason(mut self, reason: impl Into<String>) -> Self {
        self.reason = reason.into();
        self
    }

    /// Set a suggested stop-loss price.
    pub fn with_stop_loss(mut self, price: f64) -> Self {
        self.stop_loss = Some(price);
        self
    }

    /// Set a suggested take-profit price.
    pub fn with_take_profit(mut self, price: f64) -> Self {
        self.take_profit = Some(price);
        self
    }
}

/// A trading signal generated by a strategy.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Signal {
    /// Symbol the signal is for
    pub symbol: String,
    /// Type of signal
    pub signal_type: SignalType,
    /// Signal strength
    pub strength: SignalStrength,
    /// Price at the time of the signal
    pub price: f64,
    /// Timestamp (Unix milliseconds)
    pub timestamp: i64,
    /// Confidence level (0.0 to 1.0)
    pub confidence: f64,
    /// Additional metadata
    pub metadata: SignalMetadata,
}

impl Signal {
    /// Create a new signal.
    pub fn new(
        symbol: impl Into<String>,
        signal_type: SignalType,
        price: f64,
        timestamp: i64,
    ) -> Self {
        Self {
            symbol: symbol.into(),
            signal_type,
            strength: SignalStrength::Moderate,
            price,
            timestamp,
            confidence: 1.0,
            metadata: SignalMetadata::default(),
        }
    }

    /// Create a buy signal.
    pub fn buy(symbol: impl Into<String>, price: f64, timestamp: i64) -> Self {
        Self::new(symbol, SignalType::Buy, price, timestamp)
    }

    /// Create a sell signal.
    pub fn sell(symbol: impl Into<String>, price: f64, timestamp: i64) -> Self {
        Self::new(symbol, SignalType::Sell, price, timestamp)
    }

    /// Create a hold signal.
    pub fn hold(symbol: impl Into<String>, price: f64, timestamp: i64) -> Self {
        Self::new(symbol, SignalType::Hold, price, timestamp)
    }

    /// Create a close long signal.
    pub fn close_long(symbol: impl Into<String>, price: f64, timestamp: i64) -> Self {
        Self::new(symbol, SignalType::CloseLong, price, timestamp)
    }

    /// Create a close short signal.
    pub fn close_short(symbol: impl Into<String>, price: f64, timestamp: i64) -> Self {
        Self::new(symbol, SignalType::CloseShort, price, timestamp)
    }

    /// Set the signal strength.
    pub fn with_strength(mut self, strength: SignalStrength) -> Self {
        self.strength = strength;
        self
    }

    /// Set the confidence level.
    pub fn with_confidence(mut self, confidence: f64) -> Self {
        self.confidence = confidence.clamp(0.0, 1.0);
        self
    }

    /// Set the metadata.
    pub fn with_metadata(mut self, metadata: SignalMetadata) -> Self {
        self.metadata = metadata;
        self
    }

    /// Check if this signal requires action.
    pub fn requires_action(&self) -> bool {
        self.signal_type.requires_action()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_signal_type_classification() {
        assert!(SignalType::Buy.is_entry());
        assert!(SignalType::Sell.is_entry());
        assert!(!SignalType::Hold.is_entry());
        assert!(SignalType::CloseLong.is_exit());
        assert!(SignalType::CloseShort.is_exit());
    }

    #[test]
    fn test_signal_creation() {
        let signal = Signal::buy("AAPL", 150.0, 1000)
            .with_strength(SignalStrength::Strong)
            .with_confidence(0.85);

        assert_eq!(signal.symbol, "AAPL");
        assert_eq!(signal.signal_type, SignalType::Buy);
        assert_eq!(signal.strength, SignalStrength::Strong);
        assert!((signal.confidence - 0.85).abs() < 0.001);
    }

    #[test]
    fn test_signal_metadata() {
        let metadata = SignalMetadata::new("MA Crossover")
            .with_indicator("fast_ma", 155.0)
            .with_indicator("slow_ma", 150.0)
            .with_reason("Fast MA crossed above slow MA")
            .with_stop_loss(145.0);

        assert_eq!(metadata.strategy_name, "MA Crossover");
        assert_eq!(metadata.indicators.get("fast_ma"), Some(&155.0));
        assert_eq!(metadata.stop_loss, Some(145.0));
    }

    #[test]
    fn test_signal_strength_multiplier() {
        assert!((SignalStrength::Weak.multiplier() - 0.5).abs() < 0.001);
        assert!((SignalStrength::Moderate.multiplier() - 1.0).abs() < 0.001);
        assert!((SignalStrength::Strong.multiplier() - 1.5).abs() < 0.001);
    }
}
